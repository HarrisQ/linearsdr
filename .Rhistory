// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i)  ).t();
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) - (ahat + lcp) ).t();
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += wj(i)*( (ahat + lcp)  );
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += ahat;
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
//mean_nll_j += ahat;
}
return ahat;
};
' )
Dhat=opcg_list$Dhat[[1]] )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
//mean_nll_j += ahat;
}
return lcp;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += wj(i)*( (ahat + lcp)  );
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += wj(i)*( (ahat + lcp)  ).t()*( (ahat + lcp)  );
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
mean_nll_j += wj(i)*( (ahat + lcp)  ).t()*( (ahat + lcp)  );
}
return y_matrix.col(1);
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
mean_nll_j += wj(i)*( y_matrix.col(i) - (ahat + lcp) ).t()*
( y_matrix.col(i) - (ahat + lcp) )/n;
//mean_nll_j += wj(i)*( (ahat + lcp)  ).t()*( (ahat + lcp)  );
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
mean_nll_j += wj(i)*( y_matrix.col(i) - (ahat + lcp) ).t()*
( y_matrix.col(i) - (ahat + lcp) )/n;
//mean_nll_j += wj(i)*( (ahat + lcp)  ).t()*( (ahat + lcp)  );
}
return mean_nll_j;
};
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_made(arma::vec c,
arma::mat x_matrix,
arma::mat y_matrix,
double bw,
Rcpp::List ahat_list,
Rcpp::List Dhat_list,
arma::mat r_mat) {
arma::uword n; n=y_matrix.n_cols;
arma::mat mean_nll(1,1); mean_nll.zeros();
// Writing the For loop instead of sapply.
arma::uword j;
for (j = 0; j < n; j++ ) {
arma::vec ahat = ahat_list[j];
arma::mat Dhat = Dhat_list[j];
arma::mat xj = x_matrix;
xj.each_col() -= xj.col(j);
arma::mat Bxj = r_mat.t()*xj;
arma::vec wj = gauss_kern_cpp(Bxj, bw);
mean_nll += mgauss_loss_j_made(c, xj, y_matrix, wj, ahat, Dhat)/n;
}
return mean_nll;
} ;
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
mean_nll_j += wj(i)*( y_matrix.col(i) - (ahat + lcp) ).t()*
( y_matrix.col(i) - (ahat + lcp) )/n;
//mean_nll_j += wj(i)*( (ahat + lcp)  ).t()*( (ahat + lcp)  );
}
return mean_nll_j;
};
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_made(arma::vec c,
arma::mat x_matrix,
arma::mat y_matrix,
double bw,
Rcpp::List ahat_list,
Rcpp::List Dhat_list,
arma::mat r_mat) {
arma::uword n; n=y_matrix.n_cols;
arma::mat mean_nll(1,1); mean_nll.zeros();
// Writing the For loop instead of sapply.
arma::uword j;
for (j = 0; j < n; j++ ) {
arma::vec ahat = ahat_list[j];
arma::mat Dhat = Dhat_list[j];
arma::mat xj = x_matrix;
xj.each_col() -= xj.col(j);
arma::mat Bxj = r_mat.t()*xj;
arma::vec wj = ones(n);
mean_nll += mgauss_loss_j_made(c, xj, y_matrix, wj, ahat, Dhat)/n;
}
return mean_nll;
} ;
' )
mgauss_score_made(c=c_init, x_matrix = tx3,
y_matrix = ty3,
bw = 2, ahat_list = opcg_list$ahat,
Dhat_list = opcg_list$Dhat, r_mat = r_mat)
mgauss_loss_made(c=c_init, x_matrix = tx3,
y_matrix = ty3,
bw = 2, ahat_list = opcg_list$ahat,
Dhat_list = opcg_list$Dhat, r_mat = r_mat)
Rcpp::compileAttributes("C:/Users/Harri/Dropbox (Personal)/linearsdr");
devtools::install_github("HarrisQ/linearsdr");
