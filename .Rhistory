Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
for (i = 0; i < n; i++ ) {
arma::mat tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
(ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
(ahat + lcp) )/n;
}
return mean_nll_j;
};
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
for (i = 0; i < n; i++ ) {
arma::mat tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]])
opcg_list$Dhat[[1]]
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
for (i = 0; i < n; i++ ) {
arma::mat tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
//arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return tXij_tD;
};
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat.t());
//arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return tXij_tD;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]])
linearsdr:::mgauss_score_made(c=c_init, x_matrix = tx3,
y_matrix = ty3,
bw = 2, ahat_list = opcg_list$ahat,
Dhat_list = opcg_list$Dhat, r_mat = r_mat)
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=Y3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]])
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]])
linearsdr:::mgauss_score_made(c=c_init, x_matrix = tx3,
y_matrix = Y3,
bw = 2, ahat_list = opcg_list$ahat,
Dhat_list = opcg_list$Dhat, r_mat = r_mat)
linearsdr:::mgauss_score_made(c=c_init, x_matrix = tx3,
y_matrix = ty3,
bw = 2, ahat_list = opcg_list$ahat,
Dhat_list = opcg_list$Dhat, r_mat = r_mat)
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]])
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=t(opcg_list$Dhat[[1]]) )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return tXij_tD;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
(ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
(ahat + lcp) )/n;
}
return mean_nll_j;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=t(opcg_list$Dhat[[1]]) )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
opcg_list$ahat[[1]]
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
arma::vec lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return lcp;
};
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::vec lcp
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return lcp;
};
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return lcp;
};
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
//lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return I;
};
' )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
arma::uword m=y_matrix.n_rows;
arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
//lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return I;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=t(opcg_list$Dhat[[1]]) )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
//lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return tXij_tD;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=t(opcg_list$Dhat[[1]]) )
c_init
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=(opcg_list$Dhat[[1]]) )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=t(opcg_list$Dhat[[1]]) )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=t(opcg_list$Dhat[[1]]) )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
Rcpp::sourceCpp(code='
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
arma::mat mgauss_loss_j_made(arma::vec c,
arma::mat xj,
arma::mat y_matrix,
arma::vec wj,
arma::vec ahat,
arma::mat Dhat) {
arma::uword n=y_matrix.n_cols;
// arma::uword m=y_matrix.n_rows;
// arma::mat I(m,m); I.eye();
arma::mat mean_nll_j(1,1); mean_nll_j.zeros();
// Writing the For loop instead of sapply.
arma::uword i;
arma::mat tXij_tD;
arma::mat lcp;
for (i = 0; i < n; i++ ) {
tXij_tD=kron( (xj.col(i)).t(),Dhat);
lcp=tXij_tD*c;
// gaussian-loss
// the ahat*y term is free of the parameter, so we get drop it in the estimation
// mean_nll_j += -wj(i)*( lcp.t()*y_matrix.col(i) + (ahat + lcp).t()*(ahat + lcp)/2 ) /n;
// square-loss; no negative is needed
//mean_nll_j += wj(i)*( (ahat + lcp).t()* y_matrix.col(i) -
//                        (ahat + lcp) ).t()*( (ahat + lcp).t()* y_matrix.col(i) -
//                                               (ahat + lcp) )/n;
}
return lcp;
};
' )
mgauss_loss_j_made(c=c_init, xj=tx3,
y_matrix=ty3, wj=k_vec,
ahat=opcg_list$ahat[[1]],
Dhat=opcg_list$Dhat[[1]] )
opcg_list$ahat[[1]]
